module Adder where
import "lib/Prelude.dpq"
import "utils.dpq"
import "qft.dpq"


-- -------------------------------
-- -------- Cuccaro Adder --------
-- -------------------------------

maj : !(Qubit -> Qubit -> Qubit -> Qubit * Qubit * Qubit)
maj a b c =
  let (b, c) = CNot b c
      (a, c) = CNot a c
      (c, a, b) = Toffoli c a b
  in (a, b, c)


unmaj : !(Qubit -> Qubit -> Qubit -> Qubit * Qubit * Qubit)
unmaj a b c =
  let (c, a, b) = Toffoli c a b
      (a, c) = CNot a c
      (b, a)= CNot b a
  in (a, b, c)


cuccaro_adder : ! forall (n : Nat) ->
                  Vec Qubit n -> Vec Qubit n
                  -> Qubit -> Qubit ->
                  Vec Qubit n * Vec Qubit n * Qubit * Qubit
cuccaro_adder as bs c z =
  case as of
    VNil ->
      case bs of
        VNil ->
           let (z, c) = CNot z c
           in (VNil, VNil, c, z)
    VCons a as' ->
      case bs of
        VCons b bs' ->
          let (a, b, c) = maj a b c
              (as', ss, c, z) = cuccaro_adder as' bs' c z
              (a, s, c) = unmaj a b c
          in (VCons a as', VCons s ss, c, z)


cuccaro_adder_circ : ! (n : Nat) -> Circ(Vec Qubit n * Vec Qubit n * Qubit * Qubit, Vec Qubit n * Vec Qubit n * Qubit * Qubit)
cuccaro_adder_circ n = boxCirc (\ x -> let (as, bs, c, z) = x in cuccaro_adder as bs c z)


run_cuccaro_adder : ! (n : Nat) -> Vec Bool n -> Vec Bool n -> Vec Bool n * Vec Bool n
run_cuccaro_adder n bs as =
   let as = reverse_vec $ init as
       bs = reverse_vec $ init bs
       c = Init0 ()
       z = Init0 ()
       (bs, as, c, z) = (unbox (cuccaro_adder_circ n)) (bs, as, c, z)
       _ = Discard (Meas c)
       _ = Discard (Meas z)
       bs = meas_all bs
       as = meas_all as
       bs = dynlift_all bs
       as = dynlift_all as
   in (reverse_vec bs, reverse_vec as)


-- ---------------------------
-- -------- QFT Adder --------
-- ---------------------------

rotate_by_bs : ! forall (n : Nat) -> Vec Qubit n -> Vec Qubit n ->
                  Vec Qubit n * Vec Qubit n
rotate_by_bs bs as =
  case bs of
    VNil ->
      case as of
        VNil -> (VNil, VNil)
    VCons b bs ->
       case as of
         VCons a as ->
           let (a, bs') = crotates 1 a (VCons b bs)
               VCons b bs = bs'
               (bs, as) = rotate_by_bs bs as
           in (VCons b bs, VCons a as)


rotate_by_bs_circ : ! (n : Nat) -> Circ(Vec Qubit n * Vec Qubit n, Vec Qubit n * Vec Qubit n)
rotate_by_bs_circ n = boxCirc (\ x -> let (bs, as) = x in rotate_by_bs bs as)


qft_adder : ! (n : Nat) -> Circ(Vec Qubit n * Vec Qubit n, Vec Qubit n * Vec Qubit n)
qft_adder n =
  withComputed (boxCirc (\ x -> let (bs , as) = x in (bs, qft as)))
    (rotate_by_bs_circ n)


run_qft_adder : ! (n : Nat) -> Vec Bool n -> Vec Bool n -> Vec Bool n * Vec Bool n
run_qft_adder n bs as =
   let as = init as
       bs = init bs
       (bs, as) = (unbox (qft_adder n)) (bs, as)
       bs = meas_all bs
       as = meas_all as
       bs = dynlift_all bs
       as = dynlift_all as
   in (bs, as)


run_qft_adder_circ : ! {n : Nat} -> Vec Bool n -> Vec Bool n -> Circ(Unit, Vec Bit n * Vec Bit n)
run_qft_adder_circ n as bs =
    box Unit (\x ->
        let as = init as
            bs = init bs
            (bs, as) = (unbox (qft_adder n)) (bs, as)
            bs = meas_all bs
            as = meas_all as
        in (bs, as))

-- ------------------------------
-- -------- Gidney Adder --------
-- ------------------------------

logical_and : ! (Qubit -> Qubit -> Qubit * Qubit * Qubit)
logical_and x y =
    let xy = TGate (H (Init0 ())) -- Initialize a |T> state
        (xy, x) = CNot xy x
        (xy, y) = CNot xy y
        (y, xy) = CNot y xy
        (x, xy) = CNot x xy
        x = TGate_Inv x
        y = TGate_Inv y
        xy = TGate xy
        (y, xy) = CNot y xy
        (x, xy) = CNot x xy
        xy = SGate (H xy)
    in (x, y, xy)


logical_and_inv : ! (Qubit -> Qubit -> Qubit -> Qubit * Qubit)
logical_and_inv x y xy =
    let xy = dynlift (Meas (H xy))
    in case xy of
        True -> CZ x y
        False -> (x, y)
 

test_logical_and : ! (Qubit -> Qubit -> Bool)
test_logical_and x y =
    let (x, y, xy) = logical_and x y
        _ = dynlift (Meas x)
        _ = dynlift (Meas y)
        b = dynlift (Meas xy)
    in b


test_logical_and_inv : ! (Qubit -> Qubit -> Bool * Bool)
test_logical_and_inv x y =
    let (x, y, xy) = logical_and x y
        (x, y) = logical_and_inv x y xy
    in (dynlift (Meas x), dynlift (Meas y))


logical_and_inv_circ : Circ(Qubit * Qubit * Qubit, Qubit * Qubit)
logical_and_inv_circ = reverse $ boxCirc (\ x -> uncurry logical_and x)


logical_and_inv' : !(Qubit -> Qubit -> Qubit -> Qubit * Qubit)
logical_and_inv' x y xy = unbox logical_and_inv_circ (x, y, xy)


gidney_adder_rec : ! forall (n : Nat) -> Qubit -> Qubit -> Vec Qubit n -> Vec Qubit n -> Qubit * Qubit * Vec Qubit n * Vec Qubit n
gidney_adder_rec c cout as bs =
  case as of
    VNil ->
      case bs of
        VNil ->
          let (cout, c) = CNot cout c
          in (c, cout, VNil, VNil)
    VCons a ares ->
      case bs of
        VCons b bres ->
          let (a, c) = CNot a c
              (b, c) = CNot b c
              (a, b, c') = logical_and a b
              (c', c) = CNot c' c
              (c', cout, ares, bres) = gidney_adder_rec c' cout ares bres
              (c', c) = CNot c' c
              (a, b) = logical_and_inv' a b c'
              (a, c) = CNot a c
              (b, a) = CNot b a
          in (c, cout, VCons a ares, VCons b bres)


gidney_adder_circ : ! (n : Nat) -> Circ(Qubit * Qubit * Vec Qubit n * Vec Qubit n,  Qubit * Qubit * Vec Qubit n * Vec Qubit n)
gidney_adder_circ n =
  boxCirc (\ x -> let (a, b, c, d) = x in gidney_adder_rec a b c d)


run_gidney_adder : ! (n : Nat) -> Vec Bool n -> Vec Bool n -> Vec Bool n * Vec Bool n
run_gidney_adder n as bs =
   let as = reverse_vec $ init as
       bs = reverse_vec $ init bs
       c = Init0 ()
       z = Init0 ()
       (c, z, as, bs) = (unbox (gidney_adder_circ n)) (c, z, as, bs)
       _ = Discard (Meas c)
       _ = Discard (Meas z)
       bs = meas_all bs
       as = meas_all as
       bs = dynlift_all bs
       as = dynlift_all as
   in (reverse_vec as, reverse_vec bs)
