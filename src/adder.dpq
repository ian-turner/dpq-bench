module Adder where
import "lib/Prelude.dpq"
import "utils.dpq"
import "qft.dpq"


maj : !(Qubit -> Qubit -> Qubit -> Qubit * Qubit * Qubit)
maj a b c =
  let (b, c) = CNot b c
      (a, c) = CNot a c
      (c, a, b) = Toffoli c a b
  in (a, b, c)


unmaj : !(Qubit -> Qubit -> Qubit -> Qubit * Qubit * Qubit)
unmaj a b c =
  let (c, a, b) = Toffoli c a b
      (a, c) = CNot a c
      (b, a)= CNot b a
  in (a, b, c)


rotate_by_bs : ! forall (n : Nat) -> Vec Qubit n -> Vec Qubit n ->
                  Vec Qubit n * Vec Qubit n
rotate_by_bs bs as =
  case bs of
    VNil ->
      case as of
        VNil -> (VNil, VNil)
    VCons b bs ->
       case as of
         VCons a as ->
           let (a, bs') = crotates 1 a (VCons b bs)
               VCons b bs = bs'
               (bs, as) = rotate_by_bs bs as
           in (VCons b bs, VCons a as)


rotate_by_bs_circ : ! (n : Nat) -> Circ(Vec Qubit n * Vec Qubit n, Vec Qubit n * Vec Qubit n)
rotate_by_bs_circ n = boxCirc (\ x -> let (bs, as) = x in rotate_by_bs bs as)


qft_adder : ! (n : Nat) -> Circ(Vec Qubit n * Vec Qubit n, Vec Qubit n * Vec Qubit n)
qft_adder n =
  withComputed (boxCirc (\ x -> let (bs , as) = x in (bs, qft as)))
    (rotate_by_bs_circ n)


run_adder : ! (n : Nat) -> Vec Bool n -> Vec Bool n -> Vec Bool n * Vec Bool n
run_adder n bs as =
   let as = init as
       bs = init bs
   in measure $ unbox (qft_adder n) (bs, as)


-- test_adder : ! (Nat -> Nat -> Nat -> Nat)
-- test_adder n x y = binary_to_nat (snd (run_adder n (nat_to_binary n x) (nat_to_binary n y)))
