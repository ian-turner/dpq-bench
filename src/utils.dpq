module Utils where
import "lib/Prelude.dpq"


init_n : ! (n : Nat) -> Vec Qubit n
init_n n =
    case n of
        Z -> VNil
        S n' -> VCons (Init0 ()) (init_n n')


meas_all : ! forall (n : Nat) -> Vec Qubit n -> Vec Bit n
meas_all qs =
    case qs of
        VNil -> VNil
        VCons q qs' ->
            let b = Meas q
                bs = meas_all qs'
            in VCons b bs


dynlift_all : ! forall (n : Nat) -> Vec Bit n -> Vec Bool n
dynlift_all bs =
    case bs of
        VNil -> VNil
        VCons b bs' ->
            let d = dynlift b
                ds = dynlift_all bs'
            in VCons d ds


binary_to_nat_rec : ! forall (n : Nat) -> Vec Bool n -> Nat
binary_to_nat_rec bs =
    case bs of
        VNil -> 0
        VCons b bs' -> (if b then 1 else 0) + mul 2 (binary_to_nat_rec bs')


binary_to_nat : ! {n : Nat} -> Vec Bool n -> Nat
binary_to_nat n bs = binary_to_nat_rec (reverse_vec bs)


nat_to_binary_rec : ! (n : Nat) -> Nat -> Vec Bool n
nat_to_binary_rec n x =
    case n of
        Z -> VNil
        S n' ->
            let b = (if (mod x 2) == 1 then True else False)
                bs = (nat_to_binary_rec n' (div x 2))
            in VCons b bs


nat_to_binary : ! (n : Nat) -> Nat -> Vec Bool n
nat_to_binary n x = reverse_vec (nat_to_binary_rec n x)


all_hs : ! forall (n : Nat) -> Vec Qubit n -> Vec Qubit n
all_hs xs =
    case xs of
        VNil -> VNil
        VCons x xs' -> VCons (H x) (all_hs xs')


repeat_f : ! {a : Type} -> (n : Nat) -> (!(Unit -> a)) -> Vec a n
repeat_f a n f =
    case n of
        Z -> VNil
        S n' -> VCons (f ()) (repeat_f n' f)


bitstr_eq : ! forall (n : Nat) -> Vec Bool n -> Vec Bool n -> Bool
bitstr_eq xs ys =
    case xs of
        VNil -> True
        VCons x xs ->
            case ys of
                VCons y ys -> if (x == y) then (bitstr_eq xs ys) else False


get_counts : ! forall (n m : Nat) -> Vec (Vec Bool n) m -> Vec Bool n -> Nat
get_counts samples bitstr =
    case samples of
        VNil -> Z
        VCons s samples' ->
            let c = if (bitstr_eq s bitstr) then 1 else 0
            in c + (get_counts samples' bitstr)


pow : ! (Nat -> Nat -> Nat)
pow x y =
    case y of
        Z -> 1
        S y' -> mul x (pow x y')
